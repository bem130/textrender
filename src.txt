./src\app.rs
/// アプリケーション全体で共有される状態を保持する構造体
pub struct App {
    /// ユーザーが入力したテキスト
    pub input_text: String,
    /// 画面下部に表示されるステータスメッセージ
    pub status_text: String,
    /// アプリケーションが終了すべきかどうかを示すフラグ
    pub should_quit: bool,
}

impl App {
    /// Appの新しいインスタンスを生成する
    pub fn new() -> Self {
        Self {
            input_text: "Hello, World!".to_string(),
            status_text: "Press any key. (ESC or 'q' to quit)".to_string(),
            should_quit: false,
        }
    }

    /// 文字キーが押された時の処理
    pub fn on_key(&mut self, c: char) {
        self.input_text.push(c);
        self.status_text = format!("Pressed: '{}', Length: {}", c, self.input_text.len());
    }

    /// バックスペースキーが押された時の処理
    pub fn on_backspace(&mut self) {
        if self.input_text.pop().is_some() {
            self.status_text = format!("Backspace pressed. Length: {}", self.input_text.len());
        }
    }
}
---

./src\gui.rs
// src/gui.rs

use crate::app::App;
use crate::renderer::{gui_renderer, BG_COLOR};
use crate::ui::{self, Renderable};
use ab_glyph::{Font, FontRef};
use minifb::{Key, KeyRepeat, Window, WindowOptions};

const WIDTH: usize = 800;
const HEIGHT: usize = 100;
const BIG_FONT_SIZE: f32 = 48.0;
const NORMAL_FONT_SIZE: f32 = 16.0;

/// GUIアプリケーションのメイン関数
pub fn run() -> Result<(), Box<dyn std::error::Error>> {
    let font_data = include_bytes!("../fonts/NotoSerifJP-Regular.ttf");
    let font = FontRef::try_from_slice(font_data)?;

    let mut window = Window::new("GUI Text Input", WIDTH, HEIGHT, WindowOptions::default())?;
    window.limit_update_rate(Some(std::time::Duration::from_micros(16600)));
    let mut app = App::new();

    // メインループ
    while window.is_open() && !app.should_quit {
        handle_input(&mut window, &mut app);

        // 1. 背景色でピクセルバッファをクリア
        let mut pixel_buffer = vec![BG_COLOR; WIDTH * HEIGHT];

        // 2. UI定義から描画リストを取得
        let render_list = ui::build_ui(&app);

        // 3. 描画リストの各要素を解釈して描画
        for item in render_list {
            match item {
                Renderable::BigText { text, anchor, margin } => {
                    let pos = ui::calculate_position(anchor, margin, WIDTH, HEIGHT);
                    gui_renderer::draw_text(
                        &mut pixel_buffer, WIDTH, &font, text,
                        (pos.0 as f32, pos.1 as f32), BIG_FONT_SIZE,
                    );
                }
                Renderable::Text { text, anchor, margin } => {
                    let pos = ui::calculate_position(anchor, margin, WIDTH, HEIGHT);
                    gui_renderer::draw_text(
                        &mut pixel_buffer, WIDTH, &font, text,
                        (pos.0 as f32, pos.1 as f32), NORMAL_FONT_SIZE,
                    );
                }
            }
        }
        
        // 4. 完成したバッファをウィンドウに表示
        window.update_with_buffer(&pixel_buffer, WIDTH, HEIGHT)?;
    }
    Ok(())
}

/// キーボード入力を処理する
fn handle_input(window: &mut Window, app: &mut App) {
    if window.is_key_down(Key::Escape) {
        app.should_quit = true;
    }
    
    for key in window.get_keys_pressed(KeyRepeat::Yes) {
        match key {
            Key::Backspace => app.on_backspace(),
            Key::Enter => app.on_key('\n'),
            Key::Space => app.on_key(' '),
            _ => {
                if let Some(char_key) = key_to_char(key, window.is_key_down(Key::LeftShift) || window.is_key_down(Key::RightShift)) {
                    app.on_key(char_key);
                }
            }
        }
    }
}

// キーコードを文字に変換するヘルパー関数 (変更なし)
fn key_to_char(key: Key, is_shift: bool) -> Option<char> {
    match (key, is_shift) {
        (Key::A, false) => Some('a'), (Key::A, true) => Some('A'),
        (Key::B, false) => Some('b'), (Key::B, true) => Some('B'),
        (Key::C, false) => Some('c'), (Key::C, true) => Some('C'),
        (Key::D, false) => Some('d'), (Key::D, true) => Some('D'),
        (Key::E, false) => Some('e'), (Key::E, true) => Some('E'),
        (Key::F, false) => Some('f'), (Key::F, true) => Some('F'),
        (Key::G, false) => Some('g'), (Key::G, true) => Some('G'),
        (Key::H, false) => Some('h'), (Key::H, true) => Some('H'),
        (Key::I, false) => Some('i'), (Key::I, true) => Some('I'),
        (Key::J, false) => Some('j'), (Key::J, true) => Some('J'),
        (Key::K, false) => Some('k'), (Key::K, true) => Some('K'),
        (Key::L, false) => Some('l'), (Key::L, true) => Some('L'),
        (Key::M, false) => Some('m'), (Key::M, true) => Some('M'),
        (Key::N, false) => Some('n'), (Key::N, true) => Some('N'),
        (Key::O, false) => Some('o'), (Key::O, true) => Some('O'),
        (Key::P, false) => Some('p'), (Key::P, true) => Some('P'),
        (Key::Q, false) => Some('q'), (Key::Q, true) => Some('Q'),
        (Key::R, false) => Some('r'), (Key::R, true) => Some('R'),
        (Key::S, false) => Some('s'), (Key::S, true) => Some('S'),
        (Key::T, false) => Some('t'), (Key::T, true) => Some('T'),
        (Key::U, false) => Some('u'), (Key::U, true) => Some('U'),
        (Key::V, false) => Some('v'), (Key::V, true) => Some('V'),
        (Key::W, false) => Some('w'), (Key::W, true) => Some('W'),
        (Key::X, false) => Some('x'), (Key::X, true) => Some('X'),
        (Key::Y, false) => Some('y'), (Key::Y, true) => Some('Y'),
        (Key::Z, false) => Some('z'), (Key::Z, true) => Some('Z'),
        (Key::Key0, false) => Some('0'), (Key::Key0, true) => Some(')'),
        (Key::Key1, false) => Some('1'), (Key::Key1, true) => Some('!'),
        (Key::Key2, false) => Some('2'), (Key::Key2, true) => Some('@'),
        (Key::Key3, false) => Some('3'), (Key::Key3, true) => Some('#'),
        (Key::Key4, false) => Some('4'), (Key::Key4, true) => Some('$'),
        (Key::Key5, false) => Some('5'), (Key::Key5, true) => Some('%'),
        (Key::Key6, false) => Some('6'), (Key::Key6, true) => Some('^'),
        (Key::Key7, false) => Some('7'), (Key::Key7, true) => Some('&'),
        (Key::Key8, false) => Some('8'), (Key::Key8, true) => Some('*'),
        (Key::Key9, false) => Some('9'), (Key::Key9, true) => Some('('),
        (Key::Comma, false) => Some(','), (Key::Comma, true) => Some('<'),
        (Key::Period, false) => Some('.'), (Key::Period, true) => Some('>'),
        (Key::Slash, false) => Some('/'), (Key::Slash, true) => Some('?'),
        (Key::Semicolon, false) => Some(';'), (Key::Semicolon, true) => Some(':'),
        (Key::Equal, false) => Some('='), (Key::Equal, true) => Some('+'),
        (Key::Minus, false) => Some('-'), (Key::Minus, true) => Some('_'),
        _ => None,
    }
}
---

./src\lib.rs
// アプリケーションの共通モジュールを宣言
pub mod app;
pub mod renderer;
pub mod ui;

// "gui" featureが有効な時だけコンパイルされるGUIバックエンドモジュール
#[cfg(feature = "gui")]
pub mod gui;

// "tui" featureが有効な時だけコンパイルされるTUIバックエンドモジュール
#[cfg(feature = "tui")]
pub mod tui;

// "wasm" featureが有効な時だけコンパイルされるWASMバックエンドモジュール
#[cfg(feature = "wasm")]
pub mod wasm;
---

./src\main.rs
/// main関数 - featureフラグに応じて各バックエンドを起動
fn main() -> Result<(), Box<dyn std::error::Error>> {
    // "gui" featureが有効な場合にコンパイルされるブロック
    #[cfg(feature = "gui")]
    {
        println!("Starting GUI version... (Close the window or press ESC to exit)");
        return rust_multibackend_app::gui::run();
    }

    // "gui" が無効で "tui" が有効な場合にコンパイルされるブロック
    #[cfg(all(not(feature = "gui"), feature = "tui"))]
    {
        println!("Starting TUI version... (Press 'q' to exit)");
        std::thread::sleep(std::time::Duration::from_secs(2));
        return rust_multibackend_app::tui::run();
    }

    // デスクトップ用featureが一つも有効でない場合にコンパイルされるブロック
    #[cfg(not(any(feature = "gui", feature = "tui")))]
    {
        println!("No desktop backend feature enabled. Please run with --features gui or --features tui");
        return Ok(());
    }
}
---

./src\renderer.rs
use ab_glyph::{point, Font, FontRef, OutlinedGlyph};

/// テキストの描画色
pub const TEXT_COLOR: u32 = 0x00_FFFFFF;
/// 背景の描画色
pub const BG_COLOR: u32 = 0x00_101010;

/// GUI/WASMバックエンド用のピクセルベースレンダラ
pub mod gui_renderer {
    use super::*;

    /// 指定されたピクセルバッファの指定位置にテキストを描画する
    pub fn draw_text(
        buffer: &mut [u32], width: usize, font: &FontRef, text: &str,
        pos: (f32, f32), font_size: f32,
    ) {
        let scale = font_size / (font.ascent_unscaled() - font.descent_unscaled());
        let mut pen_x = pos.0;
        let pen_y = pos.1;

        for character in text.chars() {
            let glyph = font.glyph_id(character).with_scale_and_position(font_size, point(pen_x, pen_y));
            if let Some(outlined) = font.outline_glyph(glyph) {
                draw_glyph_to_pixel_buffer(buffer, width, &outlined);
            }
            pen_x += font.h_advance_unscaled(font.glyph_id(character)) * scale;
        }
    }
    
    /// アウトライン化されたグリフをピクセルバッファに描画する（内部関数）
    fn draw_glyph_to_pixel_buffer(buffer: &mut [u32], width: usize, outlined: &OutlinedGlyph) {
        let bounds = outlined.px_bounds();
        outlined.draw(|x, y, c| {
            let buffer_x = bounds.min.x as i32 + x as i32;
            let buffer_y = bounds.min.y as i32 + y as i32;
            let height = buffer.len() / width;
            if buffer_x >= 0 && buffer_x < width as i32 && buffer_y >= 0 && buffer_y < height as i32 {
                let index = (buffer_y as usize) * width + (buffer_x as usize);
                let text_r = ((TEXT_COLOR >> 16) & 0xFF) as f32;
                let text_g = ((TEXT_COLOR >> 8) & 0xFF) as f32;
                let text_b = (TEXT_COLOR & 0xFF) as f32;
                let bg_r = ((BG_COLOR >> 16) & 0xFF) as f32;
                let bg_g = ((BG_COLOR >> 8) & 0xFF) as f32;
                let bg_b = (BG_COLOR & 0xFF) as f32;
                let r = (text_r * c + bg_r * (1.0 - c)) as u32;
                let g = (text_g * c + bg_g * (1.0 - c)) as u32;
                let b = (text_b * c + bg_b * (1.0 - c)) as u32;
                buffer[index] = (r << 16) | (g << 8) | b;
            }
        });
    }
}

/// TUIバックエンド用の文字ベースレンダラ
pub mod tui_renderer {
    use super::*;
    
    /// 全画面に大きなテキストを描画し、文字バッファを返す
    pub fn render(font: &FontRef, text: &str, width: usize, height: usize) -> Vec<char> {
        let mut buffer = vec![' '; width * height];
        let font_size = height as f32 * 0.8;
        let scale = font_size / (font.ascent_unscaled() - font.descent_unscaled());
        let mut pen_x = 2.0;
        let pen_y = height as f32 * 0.7;

        for character in text.chars() {
            let glyph = font.glyph_id(character).with_scale_and_position(font_size, point(pen_x, pen_y));
            if let Some(outlined) = font.outline_glyph(glyph) {
                draw_glyph_to_char_buffer(&mut buffer, width, &outlined);
            }
            pen_x += font.h_advance_unscaled(font.glyph_id(character)) * scale;
        }
        buffer
    }
    
    /// アウトライン化されたグリフを文字バッファに描画する（内部関数）
    fn draw_glyph_to_char_buffer(buffer: &mut Vec<char>, width: usize, outlined: &OutlinedGlyph) {
        let bounds = outlined.px_bounds();
        outlined.draw(|x, y, c| {
            let buffer_x = bounds.min.x as usize + x as usize;
            let buffer_y = bounds.min.y as usize + y as usize;
            let height = buffer.len() / width;
            if buffer_x < width && buffer_y < height {
                let index = buffer_y * width + buffer_x;
                let coverage_char = match (c * 4.0).round() as u8 {
                    0 => ' ', 1 => '.', 2 => '*', 3 => '#', _ => '@',
                };
                if buffer[index] == ' ' { buffer[index] = coverage_char; }
            }
        });
    }
}
---

./src\tui.rs
use crate::app::App;
use crate::renderer::tui_renderer;
use crate::ui::{self, Renderable};
use ab_glyph::{Font, FontRef};
use crossterm::{
    cursor, event, execute,
    event::{Event, KeyCode, KeyEventKind},
    style::Print,
    terminal,
};
use std::io::{stdout, Write};
use std::time::Duration;

/// TUIアプリケーションのメイン関数
pub fn run() -> Result<(), Box<dyn std::error::Error>> {
    let font_data = include_bytes!("../fonts/NotoSerifJP-Regular.ttf");
    let font = FontRef::try_from_slice(font_data)?;

    let mut stdout = stdout();
    terminal::enable_raw_mode()?;
    execute!(stdout, terminal::EnterAlternateScreen, cursor::Hide)?;
    let mut app = App::new();

    // メインループ
    while !app.should_quit {
        let (cols, rows) = terminal::size()?;
        let (cols, rows) = (cols as usize, rows as usize);

        let mut char_buffer = vec![' '; cols * rows];
        let render_list = ui::build_ui(&app);

        for item in render_list {
            match item {
                Renderable::BigText { text, .. } => {
                    let text_layer = tui_renderer::render(&font, text, cols, rows);
                    for (i, ch) in text_layer.iter().enumerate() {
                        if *ch != ' ' {
                            char_buffer[i] = *ch;
                        }
                    }
                }
                Renderable::Text {
                    text,
                    anchor,
                    margin,
                } => {
                    let pos = ui::calculate_position(anchor, margin, cols, rows);
                    let mut x = pos.0;
                    let y = pos.1;
                    if y < 0 || y >= rows as i32 {
                        continue;
                    }
                    for c in text.chars() {
                        if x >= 0 && x < cols as i32 {
                            char_buffer[(y as usize) * cols + (x as usize)] = c;
                        }
                        x += 1;
                    }
                }
            }
        }
        draw_buffer_to_terminal(&mut stdout, &char_buffer, cols)?;
        handle_input(&mut app)?;
    }

    execute!(stdout, cursor::Show, terminal::LeaveAlternateScreen)?;
    terminal::disable_raw_mode()?;
    Ok(())
}

/// 文字バッファをターミナルに描画する
fn draw_buffer_to_terminal(
    stdout: &mut impl Write,
    buffer: &[char],
    width: usize,
) -> std::io::Result<()> {
    execute!(stdout, cursor::MoveTo(0, 0))?;
    for row in buffer.chunks(width) {
        let line: String = row.iter().collect();
        execute!(stdout, Print(line), cursor::MoveToNextLine(1))?;
    }
    // stdout.flush()がResultを返すため、これがこの関数の戻り値になる
    stdout.flush()
}

/// キーボード入力を処理する
fn handle_input(app: &mut App) -> std::io::Result<()> {
    if event::poll(Duration::from_millis(100))? {
        if let Event::Key(key) = event::read()? {
            if key.kind == KeyEventKind::Press {
                match key.code {
                    KeyCode::Char('q') => app.should_quit = true,
                    KeyCode::Char(c) => app.on_key(c),
                    KeyCode::Backspace => app.on_backspace(),
                    _ => {}
                }
            }
        }
    }
    // エラーが起きなかった場合に成功(Ok)を返す
    Ok(())
}
---

./src\ui.rs
use crate::app::App;

/// 画面上の描画基準点を定義するenum
#[derive(Clone, Copy)]
pub enum Anchor {
    TopLeft,
    TopCenter,
    TopRight,
    CenterLeft,
    Center,
    CenterRight,
    BottomLeft,
    BottomCenter,
    BottomRight,
}

/// Anchorからのオフセット（余白）を定義する構造体
#[derive(Clone, Copy)]
pub struct Margin {
    pub x: i32,
    pub y: i32,
}

/// 画面に描画すべき要素の種類とレイアウト情報を定義するenum
pub enum Renderable<'a> {
    /// 通常のフォントサイズで描画されるテキスト
    Text {
        text: &'a str,
        anchor: Anchor,
        margin: Margin,
    },
    /// 大きなフォントサイズで描画されるテキスト
    BigText {
        text: &'a str,
        anchor: Anchor,
        margin: Margin,
    },
}

/// Appの状態を受け取り、描画リスト（UIレイアウト）を構築する
pub fn build_ui<'a>(app: &'a App) -> Vec<Renderable<'a>> {
    vec![
        // 画面中央に表示する大きなテキスト
        Renderable::BigText {
            text: &app.input_text,
            anchor: Anchor::Center,
            margin: Margin { x: 0, y: 0 },
        },
        // 画面左下に表示するステータステキスト
        Renderable::Text {
            text: &app.status_text,
            anchor: Anchor::BottomLeft,
            margin: Margin { x: 5, y: -5 },
        },
    ]
}

/// AnchorとMarginから、具体的な描画開始座標(x, y)を計算する
pub fn calculate_position(anchor: Anchor, margin: Margin, width: usize, height: usize) -> (i32, i32) {
    let (w, h) = (width as i32, height as i32);
    let base_pos = match anchor {
        Anchor::TopLeft => (0, 0),
        Anchor::TopCenter => (w / 2, 0),
        Anchor::TopRight => (w, 0),
        Anchor::CenterLeft => (0, h / 2),
        Anchor::Center => (w / 2, h / 2),
        Anchor::CenterRight => (w, h / 2),
        Anchor::BottomLeft => (0, h),
        Anchor::BottomCenter => (w / 2, h),
        Anchor::BottomRight => (w, h),
    };
    (base_pos.0 + margin.x, base_pos.1 + margin.y)
}
---

./src\wasm.rs
use crate::app::App;
use crate::renderer::{gui_renderer, BG_COLOR};
use crate::ui::{self, Renderable};
use ab_glyph::{Font, FontRef};
use std::cell::RefCell;
use std::rc::Rc;
use wasm_bindgen::prelude::*;
use wasm_bindgen::Clamped;
use web_sys::{CanvasRenderingContext2d, ImageData, KeyboardEvent};

const WIDTH: usize = 800;
const HEIGHT: usize = 100;
const BIG_FONT_SIZE: f32 = 48.0;
const NORMAL_FONT_SIZE: f32 = 16.0;

/// WASMモジュールのエントリーポイント
#[wasm_bindgen(start)]
pub fn start() -> Result<(), JsValue> {
    console_error_panic_hook::set_once();
    let window = web_sys::window().unwrap();
    let document = window.document().unwrap();
    let body = document.body().unwrap();

    let canvas = document.create_element("canvas")?.dyn_into::<web_sys::HtmlCanvasElement>()?;
    canvas.set_width(WIDTH as u32);
    canvas.set_height(HEIGHT as u32);
    body.append_child(&canvas)?;
    let context = canvas.get_context("2d")?.unwrap().dyn_into::<CanvasRenderingContext2d>()?;

    let font = FontRef::try_from_slice(include_bytes!("../fonts/NotoSerifJP-Regular.ttf"))
        .map_err(|e| JsValue::from_str(&e.to_string()))?;

    let app = Rc::new(RefCell::new(App::new()));

    // キーボードイベントのリスナーを設定
    {
        let app_clone = app.clone();
        let closure = Closure::<dyn FnMut(_)>::new(move |event: KeyboardEvent| {
            let mut app = app_clone.borrow_mut();
            match event.key().as_str() {
                "Backspace" => app.on_backspace(),
                "Enter" => app.on_key('\n'),
                key if key.len() == 1 => app.on_key(key.chars().next().unwrap()),
                _ => {}
            }
        });
        document.add_event_listener_with_callback("keydown", closure.as_ref().unchecked_ref())?;
        closure.forget();
    }

    // requestAnimationFrameによるメインループ
    let f = Rc::new(RefCell::new(None));
    let g = f.clone();
    *g.borrow_mut() = Some(Closure::<dyn FnMut()>::new(move || {
        let app = app.borrow(); // 描画中は不変借用

        // 1. 背景色でピクセルバッファをクリア
        let mut pixel_buffer = vec![BG_COLOR; WIDTH * HEIGHT];

        // 2. UI定義から描画リストを取得
        let render_list = ui::build_ui(&app);

        // 3. 描画リストを解釈して描画
        for item in render_list {
            match item {
                 Renderable::BigText { text, anchor, margin } => {
                    let pos = ui::calculate_position(anchor, margin, WIDTH, HEIGHT);
                    gui_renderer::draw_text(
                        &mut pixel_buffer, WIDTH, &font, text,
                        (pos.0 as f32, pos.1 as f32), BIG_FONT_SIZE,
                    );
                }
                Renderable::Text { text, anchor, margin } => {
                    let pos = ui::calculate_position(anchor, margin, WIDTH, HEIGHT);
                    gui_renderer::draw_text(
                        &mut pixel_buffer, WIDTH, &font, text,
                        (pos.0 as f32, pos.1 as f32), NORMAL_FONT_SIZE,
                    );
                }
            }
        }
        
        // 4. 完成したバッファをCanvasに転送
        let mut u8_buffer = Vec::with_capacity(WIDTH * HEIGHT * 4);
        for pixel in pixel_buffer.iter() {
            u8_buffer.extend_from_slice(&[((*pixel >> 16) & 0xFF) as u8, ((*pixel >> 8) & 0xFF) as u8, (*pixel & 0xFF) as u8, 255]);
        }
        let image_data = ImageData::new_with_u8_clamped_array_and_sh(Clamped(&u8_buffer), WIDTH as u32, HEIGHT as u32).unwrap();
        context.put_image_data(&image_data, 0.0, 0.0).unwrap();

        // 次のフレームを要求
        request_animation_frame(f.borrow().as_ref().unwrap());
    }));
    request_animation_frame(g.borrow().as_ref().unwrap());

    Ok(())
}

/// requestAnimationFrameを呼び出すヘルパー関数
fn request_animation_frame(f: &Closure<dyn FnMut()>) {
    web_sys::window().unwrap().request_animation_frame(f.as_ref().unchecked_ref()).unwrap();
}
---

