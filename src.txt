./src\app.rs
// ./src/app.rs

// uefi featureが有効な場合、標準のallocクレートをインポート
#[cfg(feature = "uefi")]
extern crate alloc;

// uefi と std で使用する String と format! を切り替える
#[cfg(feature = "uefi")]
use alloc::{format, string::{String, ToString}};
#[cfg(not(feature = "uefi"))]
use std::string::{String, ToString};


/// アプリケーション全体で共有される状態を保持する構造体
pub struct App {
    /// ユーザーが入力したテキスト
    pub input_text: String,
    /// 画面下部に表示されるステータスメッセージ
    pub status_text: String,
    /// アプリケーションが終了すべきかどうかを示すフラグ
    pub should_quit: bool,
}

impl App {
    /// Appの新しいインスタンスを生成する
    pub fn new() -> Self {
        Self {
            input_text: "Hello, UEFI!".to_string(),
            status_text: "Press any key. (ESC to quit)".to_string(),
            should_quit: false,
        }
    }

    /// 文字キーが押された時の処理
    pub fn on_key(&mut self, c: char) {
        if c != '\u{0}' { // NUL文字は無視する
            self.input_text.push(c);
            self.status_text = format!("Pressed: '{}', Length: {}", c, self.input_text.len());
        }
    }

    /// バックスペースキーが押された時の処理
    pub fn on_backspace(&mut self) {
        if self.input_text.pop().is_some() {
            self.status_text = format!("Backspace pressed. Length: {}", self.input_text.len());
        }
    }
}
---

./src\gui.rs
// src/gui.rs

use crate::app::App;
use crate::renderer::{gui_renderer, BG_COLOR};
use crate::ui::{self, Renderable};
use ab_glyph::FontRef;
use minifb::{Key, KeyRepeat, Window, WindowOptions};

const NORMAL_FONT_SIZE: f32 = 16.0;

/// GUIアプリケーションのメイン関数
pub fn run() -> Result<(), Box<dyn std::error::Error>> {
    let font_data = include_bytes!("../fonts/NotoSerifJP-Regular.ttf");
    let font = FontRef::try_from_slice(font_data).map_err(|_| "Failed to load font from slice")?;

    let mut width = 800;
    let mut height = 300;

    let mut window = Window::new(
        "GUI Text Input",
        width,
        height,
        WindowOptions {
            resize: true,
            ..WindowOptions::default()
        },
    )?;
    window.set_target_fps(60);
    let mut app = App::new();
    let mut big_font_size = height as f32 * 0.5;

    // メインループ
    while window.is_open() && !app.should_quit {
        let (new_width, new_height) = window.get_size();
        if new_width != width || new_height != height {
            width = new_width;
            height = new_height;
            big_font_size = height as f32 * 0.5;
        }

        handle_input(&mut window, &mut app);

        // 1. 背景色でピクセルバッファをクリア
        let mut pixel_buffer = vec![BG_COLOR; width * height];

        // 2. UI定義から描画リストを取得
        let render_list = ui::build_ui(&app);

        // 3. 描画リストの各要素を解釈して描画
        for item in render_list {
            match item {
                Renderable::BigText { text, anchor, shift, align } => {
                    let (text_width, text_height, _ascent) = gui_renderer::measure_text(&font, text, big_font_size);
                    let anchor_pos = ui::calculate_anchor_position(anchor, shift, width, height);
                    let (x, y) = ui::calculate_aligned_position(anchor_pos, text_width, text_height, align);
                    gui_renderer::draw_text(
                        &mut pixel_buffer, width, &font, text,
                        (x as f32, y as f32), big_font_size,
                    );
                }
                Renderable::Text { text, anchor, shift, align } => {
                    let (text_width, text_height, ascent) = gui_renderer::measure_text(&font, text, NORMAL_FONT_SIZE);
                    let anchor_pos = ui::calculate_anchor_position(anchor, shift, width, height);
                    let (x, y) = ui::calculate_aligned_position(anchor_pos, text_width, text_height, align);
                    gui_renderer::draw_text(
                        &mut pixel_buffer, width, &font, text,
                        (x as f32, y as f32), NORMAL_FONT_SIZE,
                    );
                }
            }
        }
        
        // 4. 完成したバッファをウィンドウに表示
        window.update_with_buffer(&pixel_buffer, width, height)?;
    }
    Ok(())
}

/// キーボード入力を処理する
fn handle_input(window: &mut Window, app: &mut App) {
    if window.is_key_down(Key::Escape) {
        app.should_quit = true;
    }
    
    for key in window.get_keys_pressed(KeyRepeat::Yes) {
        match key {
            Key::Backspace => app.on_backspace(),
            Key::Enter => app.on_key('\n'),
            Key::Space => app.on_key(' '),
            _ => {
                if let Some(char_key) = key_to_char(key, window.is_key_down(Key::LeftShift) || window.is_key_down(Key::RightShift)) {
                    app.on_key(char_key);
                }
            }
        }
    }
}

// キーコードを文字に変換するヘルパー関数 (変更なし)
fn key_to_char(key: Key, is_shift: bool) -> Option<char> {
    match (key, is_shift) {
        (Key::A, false) => Some('a'), (Key::A, true) => Some('A'),
        (Key::B, false) => Some('b'), (Key::B, true) => Some('B'),
        (Key::C, false) => Some('c'), (Key::C, true) => Some('C'),
        (Key::D, false) => Some('d'), (Key::D, true) => Some('D'),
        (Key::E, false) => Some('e'), (Key::E, true) => Some('E'),
        (Key::F, false) => Some('f'), (Key::F, true) => Some('F'),
        (Key::G, false) => Some('g'), (Key::G, true) => Some('G'),
        (Key::H, false) => Some('h'), (Key::H, true) => Some('H'),
        (Key::I, false) => Some('i'), (Key::I, true) => Some('I'),
        (Key::J, false) => Some('j'), (Key::J, true) => Some('J'),
        (Key::K, false) => Some('k'), (Key::K, true) => Some('K'),
        (Key::L, false) => Some('l'), (Key::L, true) => Some('L'),
        (Key::M, false) => Some('m'), (Key::M, true) => Some('M'),
        (Key::N, false) => Some('n'), (Key::N, true) => Some('N'),
        (Key::O, false) => Some('o'), (Key::O, true) => Some('O'),
        (Key::P, false) => Some('p'), (Key::P, true) => Some('P'),
        (Key::Q, false) => Some('q'), (Key::Q, true) => Some('Q'),
        (Key::R, false) => Some('r'), (Key::R, true) => Some('R'),
        (Key::S, false) => Some('s'), (Key::S, true) => Some('S'),
        (Key::T, false) => Some('t'), (Key::T, true) => Some('T'),
        (Key::U, false) => Some('u'), (Key::U, true) => Some('U'),
        (Key::V, false) => Some('v'), (Key::V, true) => Some('V'),
        (Key::W, false) => Some('w'), (Key::W, true) => Some('W'),
        (Key::X, false) => Some('x'), (Key::X, true) => Some('X'),
        (Key::Y, false) => Some('y'), (Key::Y, true) => Some('Y'),
        (Key::Z, false) => Some('z'), (Key::Z, true) => Some('Z'),
        (Key::Key0, false) => Some('0'), (Key::Key0, true) => Some(')'),
        (Key::Key1, false) => Some('1'), (Key::Key1, true) => Some('!'),
        (Key::Key2, false) => Some('2'), (Key::Key2, true) => Some('@'),
        (Key::Key3, false) => Some('3'), (Key::Key3, true) => Some('#'),
        (Key::Key4, false) => Some('4'), (Key::Key4, true) => Some('$'),
        (Key::Key5, false) => Some('5'), (Key::Key5, true) => Some('%'),
        (Key::Key6, false) => Some('6'), (Key::Key6, true) => Some('^'),
        (Key::Key7, false) => Some('7'), (Key::Key7, true) => Some('&'),
        (Key::Key8, false) => Some('8'), (Key::Key8, true) => Some('*'),
        (Key::Key9, false) => Some('9'), (Key::Key9, true) => Some('('),
        (Key::Comma, false) => Some(','), (Key::Comma, true) => Some('<'),
        (Key::Period, false) => Some('.'), (Key::Period, true) => Some('>'),
        (Key::Slash, false) => Some('/'), (Key::Slash, true) => Some('?'),
        (Key::Semicolon, false) => Some(';'), (Key::Semicolon, true) => Some(':'),
        (Key::Equal, false) => Some('='), (Key::Equal, true) => Some('+'),
        (Key::Minus, false) => Some('-'), (Key::Minus, true) => Some('_'),
        _ => None,
    }
}

---

./src\lib.rs
// ./src/lib.rs

// uefi featureが有効な場合、no_stdとno_mainでコンパイルする
#![cfg_attr(feature = "uefi", no_std)]
#![cfg_attr(feature = "uefi", no_main)]

// uefi featureが有効な場合にのみ必要となる設定
#[cfg(feature = "uefi")]
mod uefi_setup {
    /// uefiクレートが提供するアロケータをグローバルアロケータとして設定
    #[global_allocator]
    static ALLOCATOR: uefi::allocator::Allocator = uefi::allocator::Allocator;
}

// アプリケーションの共通モジュールを宣言
pub mod app;
pub mod renderer;
pub mod ui;

// "gui" featureが有効な時だけコンパイルされるGUIバックエンドモジュール
#[cfg(feature = "gui")]
pub mod gui;

// "tui" featureが有効な時だけコンパイルされるTUIバックエンドモジュール
#[cfg(feature = "tui")]
pub mod tui;

// "wasm" featureが有効な時だけコンパイルされるWASMバックエンドモジュール
#[cfg(feature = "wasm")]
pub mod wasm;

// "uefi" featureが有効な時だけコンパイルされるUEFIバックエンドモジュール
#[cfg(feature = "uefi")]
pub mod uefi;
---

./src\main.rs
#![cfg_attr(feature = "uefi", no_std)]
#![cfg_attr(feature = "uefi", no_main)]

/// main関数 - featureフラグに応じて各バックエンドを起動
#[cfg(not(feature = "uefi"))]
fn main() -> Result<(), Box<dyn std::error::Error>> {
    // "gui" featureが有効な場合にコンパイルされるブロック
    #[cfg(feature = "gui")]
    {
        println!("Starting GUI version... (Close the window or press ESC to exit)");
        return rust_multibackend_app::gui::run();
    }

    // "gui" が無効で "tui" が有効な場合にコンパイルされるブロック
    #[cfg(all(not(feature = "gui"), feature = "tui"))]
    {
        println!("Starting TUI version... (Press 'q' to exit)");
        // std::thread::sleep(std::time::Duration::from_secs(2));
        return rust_multibackend_app::tui::run();
    }

    // デスクトップ用featureが一つも有効でない場合にコンパイルされるブロック
    #[cfg(not(any(feature = "gui", feature = "tui")))]
    {
        println!("No desktop backend feature enabled. Please run with --features gui or --features tui");
        return Ok(());
    }
}


#[cfg(feature = "uefi")]
#[uefi::entry]
 fn efi_main() -> uefi::prelude::Status {
    // ここで `run` 関数を呼び出すか、`run` 関数の内容を直接記述します。
    // `run` 関数のシグネチャを合わせる必要があるかもしれません。
    rust_multibackend_app::uefi::run()
}
---

./src\renderer.rs
// uefi featureが有効な場合、標準のallocクレートをインポート
#[cfg(feature = "uefi")]
extern crate alloc;

// uefi と std で使用する Vec と vec! を切り替える
#[cfg(feature = "uefi")]
use alloc::vec::Vec;
#[cfg(feature = "uefi")]
use alloc::vec;
#[cfg(not(feature = "uefi"))]
use std::vec::Vec;

#[cfg(feature = "uefi")]
use core_maths::CoreFloat;

use ab_glyph::{point, Font, FontRef, OutlinedGlyph, PxScale, ScaleFont};

/// テキストの描画色
pub const TEXT_COLOR: u32 = 0x00_FFFFFF;
/// 背景の描画色
pub const BG_COLOR: u32 = 0x00_101010;

/// GUI/WASMバックエンド用のピクセルベースレンダラ
pub mod gui_renderer {
    use super::*;

    /// 指定されたピクセルバッファの指定位置にテキストを描画する
    pub fn draw_text(
        buffer: &mut [u32], stride: usize, font: &FontRef, text: &str,
        pos: (f32, f32), font_size: f32,
    ) {
        let scale = PxScale::from(font_size);
        let scaled_font = font.as_scaled(scale);
        let ascent = scaled_font.ascent();
        let mut pen_x = pos.0;
        let pen_y = pos.1 + ascent;

        let mut last_glyph = None;
        for character in text.chars() {
            let glyph_id = font.glyph_id(character);
            if let Some(last) = last_glyph {
                pen_x += scaled_font.kern(last, glyph_id);
            }
            let glyph = glyph_id.with_scale_and_position(scale, point(pen_x, pen_y));
            if let Some(outlined) = font.outline_glyph(glyph) {
                draw_glyph_to_pixel_buffer(buffer, stride, &outlined);
            }
            pen_x += scaled_font.h_advance(glyph_id);
            last_glyph = Some(glyph_id);
        }
    }
    
    /// アウトライン化されたグリフをピクセルバッファに描画する（内部関数）
    fn draw_glyph_to_pixel_buffer(buffer: &mut [u32], stride: usize, outlined: &OutlinedGlyph) {
        let bounds = outlined.px_bounds();
        outlined.draw(|x, y, c| {
            let buffer_x = bounds.min.x as i32 + x as i32;
            let buffer_y = bounds.min.y as i32 + y as i32;
            let height = buffer.len() / stride;
            if buffer_x >= 0 && buffer_x < stride as i32 && buffer_y >= 0 && buffer_y < height as i32 {
                let index = (buffer_y as usize) * stride + (buffer_x as usize);
                let text_r = ((TEXT_COLOR >> 16) & 0xFF) as f32;
                let text_g = ((TEXT_COLOR >> 8) & 0xFF) as f32;
                let text_b = (TEXT_COLOR & 0xFF) as f32;
                let bg_r = ((buffer[index] >> 16) & 0xFF) as f32;
                let bg_g = ((buffer[index] >> 8) & 0xFF) as f32;
                let bg_b = (buffer[index] & 0xFF) as f32;
                let r = (text_r * c + bg_r * (1.0 - c)) as u32;
                let g = (text_g * c + bg_g * (1.0 - c)) as u32;
                let b = (text_b * c + bg_b * (1.0 - c)) as u32;
                buffer[index] = (r << 16) | (g << 8) | b;
            }
        });
    }

    /// テキストの描画サイズ（幅と高さ）を計算する
    pub fn measure_text(font: &FontRef, text: &str, size: f32) -> (u32, u32, f32) {
        let scale = PxScale::from(size);
        let scaled_font = font.as_scaled(scale);
        let mut total_width = 0.0;

        let mut last_glyph_id = None;
        for c in text.chars() {
            if c == '\n' {
                continue;
            }
            let glyph = font.glyph_id(c);
            if let Some(last_id) = last_glyph_id {
                total_width += scaled_font.kern(last_id, glyph);
            }
            total_width += scaled_font.h_advance(glyph);
            last_glyph_id = Some(glyph);
        }
        let height = scaled_font.ascent() - scaled_font.descent();
        (total_width as u32, height as u32, scaled_font.ascent())
    }
}

/// TUIバックエンド用の文字ベースレンダラ
pub mod tui_renderer {
    use super::*;
    
    /// 全画面に大きなテキストを描画し、文字バッファを返す
    pub fn render(font: &FontRef, text: &str, width: usize, height: usize) -> Vec<char> {
        let mut buffer = vec![' '; width * height];
        let font_size = height as f32 * 0.8;
        let scale = font_size / (font.ascent_unscaled() - font.descent_unscaled());
        let mut pen_x = 2.0;
        let pen_y = height as f32 * 0.7;

        for character in text.chars() {
            let glyph = font.glyph_id(character).with_scale_and_position(font_size, point(pen_x, pen_y));
            if let Some(outlined) = font.outline_glyph(glyph) {
                draw_glyph_to_char_buffer(&mut buffer, width, &outlined);
            }
            pen_x += font.h_advance_unscaled(font.glyph_id(character)) * scale;
        }
        buffer
    }
    
    /// アウトライン化されたグリフを文字バッファに描画する（内部関数）
    fn draw_glyph_to_char_buffer(buffer: &mut Vec<char>, width: usize, outlined: &OutlinedGlyph) {
        let bounds = outlined.px_bounds();
        outlined.draw(|x, y, c| {
            let buffer_x = bounds.min.x as usize + x as usize;
            let buffer_y = bounds.min.y as usize + y as usize;
            let height = buffer.len() / width;
            if buffer_x < width && buffer_y < height {
                let index = buffer_y * width + buffer_x;
                let coverage_char = match (c * 4.0).round() as u8 {
                    0 => ' ',
                    1 => '.',
                    2 => '*',
                    3 => '#',
                    _ => '@',
                };
                if buffer[index] == ' ' { buffer[index] = coverage_char; }
            }
        });
    }

    /// テキストの描画サイズ（幅と高さ）を計算する
    pub fn measure_text(text: &str) -> (u32, u32) {
        (text.chars().count() as u32, 1)
    }
}
---

./src\tui.rs
use crate::app::App;
use crate::renderer::tui_renderer;
use crate::ui::{self, Renderable};
use ab_glyph::FontRef;
use crossterm::{
    cursor, event, execute,
    event::{Event, KeyCode, KeyEventKind},
    style::Print,
    terminal,
};
use std::io::{stdout, Write};
use std::time::Duration;

/// TUIアプリケーションのメイン関数
pub fn run() -> Result<(), Box<dyn std::error::Error>> {
    let font_data = include_bytes!("../fonts/NotoSerifJP-Regular.ttf");
    let font = FontRef::try_from_slice(font_data).map_err(|_| "Failed to load font from slice")?;

    let mut stdout = stdout();
    terminal::enable_raw_mode()?;
    execute!(stdout, terminal::EnterAlternateScreen, cursor::Hide)?;
    let mut app = App::new();

    // メインループ
    while !app.should_quit {
        let (cols, rows) = terminal::size()?;
        let (cols, rows) = (cols as usize, rows as usize);

        let mut char_buffer = vec![' '; cols * rows];
        let render_list = ui::build_ui(&app);

        for item in render_list {
            match item {
                Renderable::BigText { text, .. } => {
                    let text_layer = tui_renderer::render(&font, text, cols, rows);
                    for (i, ch) in text_layer.iter().enumerate() {
                        if *ch != ' ' {
                            char_buffer[i] = *ch;
                        }
                    }
                }
                Renderable::Text {
                    text,
                    anchor,
                    shift,
                    align,
                } => {
                    // TUIでは複雑なアライメントは実装が難しいため、単純な位置計算に留める
                    let (text_width, text_height) = tui_renderer::measure_text(text);
                    let anchor_pos = ui::calculate_anchor_position(anchor, shift, cols, rows);
                    let (mut x, y) = ui::calculate_aligned_position(anchor_pos, text_width, text_height, align);

                    if y < 0 || y >= rows as i32 {
                        continue;
                    }
                    for c in text.chars() {
                        if x >= 0 && x < cols as i32 {
                            char_buffer[(y as usize) * cols + (x as usize)] = c;
                        }
                        x += 1;
                    }
                }
            }
        }
        draw_buffer_to_terminal(&mut stdout, &char_buffer, cols)?;
        handle_input(&mut app)?;
    }

    execute!(stdout, cursor::Show, terminal::LeaveAlternateScreen)?;
    terminal::disable_raw_mode()?;
    Ok(())
}

/// 文字バッファをターミナルに描画する
fn draw_buffer_to_terminal(
    stdout: &mut impl Write,
    buffer: &[char],
    width: usize,
) -> std::io::Result<()> {
    execute!(stdout, cursor::MoveTo(0, 0))?;
    for row in buffer.chunks(width) {
        let line: String = row.iter().collect();
        execute!(stdout, Print(line), cursor::MoveToNextLine(1))?;
    }
    // stdout.flush()がResultを返すため、これがこの関数の戻り値になる
    stdout.flush()
}

/// キーボード入力を処理する
fn handle_input(app: &mut App) -> std::io::Result<()> {
    if event::poll(Duration::from_millis(100))? {
        if let Event::Key(key) = event::read()? {
            if key.kind == KeyEventKind::Press {
                match key.code {
                    KeyCode::Char('q') => app.should_quit = true,
                    KeyCode::Char(c) => app.on_key(c),
                    KeyCode::Backspace => app.on_backspace(),
                    _ => {}
                }
            }
        }
    }
    // エラーが起きなかった場合に成功(Ok)を返す
    Ok(())
}
---

./src\uefi.rs
// src/uefi.rs

extern crate alloc;

use uefi::prelude::*;
use uefi::proto::console::gop::{BltOp, BltPixel, BltRegion, GraphicsOutput};
use uefi::proto::console::text::Key;
use uefi::boot::{EventType, TimerTrigger, Tpl};
use crate::app::App;
use crate::renderer::{TEXT_COLOR, BG_COLOR};
use crate::ui::{self, Renderable};
use ab_glyph::{Font, FontRef, point, OutlinedGlyph, PxScale, ScaleFont};
use alloc::vec::Vec;

const NORMAL_FONT_SIZE: f32 = 16.0;

pub fn run() -> Status {
    uefi::helpers::init().unwrap();

    // Get Graphics Output Protocol
    let gop_handle = uefi::boot::get_handle_for_protocol::<GraphicsOutput>().unwrap();
    let mut gop = uefi::boot::open_protocol_exclusive::<GraphicsOutput>(gop_handle).unwrap();

    // Get current mode info
    let mode_info = gop.current_mode_info();
    let (width, height) = mode_info.resolution();
    let big_font_size = height as f32 * 0.5;

    // Load font
    let font_data: &[u8] = include_bytes!("../fonts/NotoSerifJP-Regular.ttf");
    let font = FontRef::try_from_slice(font_data).expect("Failed to load font");

    let mut app = App::new();

    // Create timer event for the main loop tick
    let timer_event = unsafe { uefi::boot::create_event(EventType::TIMER, Tpl::APPLICATION, None, None).unwrap() };
    uefi::boot::set_timer(&timer_event, TimerTrigger::Relative(100_000)).unwrap(); // 10ms tick

    let mut events = [timer_event];

    while !app.should_quit {
        // Wait for the timer tick
        uefi::boot::wait_for_event(&mut events).unwrap();

        // Read all available keys by returning them from the closure
        let keys: Vec<Key> = uefi::system::with_stdin(|stdin| {
            let mut collected_keys = Vec::new();
            while let Ok(Some(key)) = stdin.read_key() {
                collected_keys.push(key);
            }
            collected_keys
        });

        // Process the collected keys
        for key in keys {
            match key {
                Key::Printable(c) => {
                    let ch: char = c.into();
                    if ch == '\u{0008}' { // Backspace
                        app.on_backspace();
                    } else {
                        app.on_key(ch);
                    }
                },
                Key::Special(scan) if scan == uefi::proto::console::text::ScanCode::ESCAPE => {
                    app.should_quit = true;
                },
                _ => {},
            }
        }

        // Render
        let mut pixel_buffer: alloc::vec::Vec<BltPixel> = alloc::vec![BltPixel::new(((BG_COLOR) & 0xFF) as u8, ((BG_COLOR >> 8) & 0xFF) as u8, ((BG_COLOR >> 16) & 0xFF) as u8); width * height];

        let render_list = ui::build_ui(&app);

        for item in render_list {
            match item {
                Renderable::BigText { text, anchor, shift, align } => {
                    let (text_width, text_height, _ascent) = measure_text(&font, text, big_font_size);
                    let anchor_pos = ui::calculate_anchor_position(anchor, shift, width, height);
                    let (x, y) = ui::calculate_aligned_position(anchor_pos, text_width, text_height, align);
                    draw_text(
                        &mut pixel_buffer, width, &font, text,
                        (x as f32, y as f32), big_font_size,
                    );
                }
                Renderable::Text { text, anchor, shift, align } => {
                    let (text_width, text_height, _ascent) = measure_text(&font, text, NORMAL_FONT_SIZE);
                    let anchor_pos = ui::calculate_anchor_position(anchor, shift, width, height);
                    let (x, y) = ui::calculate_aligned_position(anchor_pos, text_width, text_height, align);
                    draw_text(
                        &mut pixel_buffer, width, &font, text,
                        (x as f32, y as f32), NORMAL_FONT_SIZE,
                    );
                }
            }
        }

        // Blt to video
        gop.blt(BltOp::BufferToVideo {
            buffer: &pixel_buffer,
            src: BltRegion::Full,
            dest: (0, 0),
            dims: (width, height),
        }).unwrap();

        // Reset timer for the next tick
        uefi::boot::set_timer(&events[0], TimerTrigger::Relative(100_000)).unwrap();
    }

    Status::SUCCESS
}

fn draw_text(
    buffer: &mut [BltPixel], stride: usize, font: &FontRef, text: &str,
    pos: (f32, f32), font_size: f32,
) {
    let scale = PxScale::from(font_size);
    let scaled_font = font.as_scaled(scale);
    let ascent = scaled_font.ascent();
    let mut pen_x = pos.0;
    let pen_y = pos.1 + ascent;

    let mut last_glyph = None;
    for character in text.chars() {
        let glyph_id = font.glyph_id(character);
        if let Some(last) = last_glyph {
            pen_x += scaled_font.kern(last, glyph_id);
        }
        let glyph = glyph_id.with_scale_and_position(scale, point(pen_x, pen_y));
        if let Some(outlined) = font.outline_glyph(glyph) {
            draw_glyph_to_pixel_buffer(buffer, stride, &outlined);
        }
        pen_x += scaled_font.h_advance(glyph_id);
        last_glyph = Some(glyph_id);
    }
}

fn draw_glyph_to_pixel_buffer(buffer: &mut [BltPixel], stride: usize, outlined: &OutlinedGlyph) {
    let bounds = outlined.px_bounds();
    outlined.draw(|x, y, c| {
        let buffer_x = bounds.min.x as i32 + x as i32;
        let buffer_y = bounds.min.y as i32 + y as i32;
        let height = buffer.len() / stride;
        if buffer_x >= 0 && buffer_x < stride as i32 && buffer_y >= 0 && buffer_y < height as i32 {
            let index = (buffer_y as usize) * stride + (buffer_x as usize);
            let text_b = (TEXT_COLOR & 0xFF) as f32;
            let text_g = ((TEXT_COLOR >> 8) & 0xFF) as f32;
            let text_r = ((TEXT_COLOR >> 16) & 0xFF) as f32;
            let bg_b = buffer[index].blue as f32;
            let bg_g = buffer[index].green as f32;
            let bg_r = buffer[index].red as f32;
            let b = (text_b * c + bg_b * (1.0 - c)) as u8;
            let g = (text_g * c + bg_g * (1.0 - c)) as u8;
            let r = (text_r * c + bg_r * (1.0 - c)) as u8;
            buffer[index] = BltPixel::new(b, g, r);
        }
    });
}

/// テキストの描画サイズを計算する
fn measure_text(font: &FontRef, text: &str, size: f32) -> (u32, u32, f32) {
    let scale = PxScale::from(size);
    let scaled_font = font.as_scaled(scale);
    let mut total_width = 0.0;

    let mut last_glyph_id = None;
    for c in text.chars() {
        if c == '\n' {
            continue;
        }
        let glyph = font.glyph_id(c);
        if let Some(last_id) = last_glyph_id {
            total_width += scaled_font.kern(last_id, glyph);
        }
        total_width += scaled_font.h_advance(glyph);
        last_glyph_id = Some(glyph);
    }
    let height = scaled_font.ascent() - scaled_font.descent();
    (total_width as u32, height as u32, scaled_font.ascent())
}

---

./src\ui.rs
// uefi featureが有効な場合、標準のallocクレートをインポート
#[cfg(feature = "uefi")]
extern crate alloc;

// uefi と std で使用する Vec と vec! を切り替える
#[cfg(feature = "uefi")]
use alloc::vec::Vec;
#[cfg(feature = "uefi")]
use alloc::vec;
#[cfg(not(feature = "uefi"))]
use std::vec::Vec;

use crate::app::App;

/// 画面上の描画基準点を定義するenum
#[derive(Clone, Copy)]
pub enum Anchor {
    TopLeft,
    TopCenter,
    TopRight,
    CenterLeft,
    Center,
    CenterRight,
    BottomLeft,
    BottomCenter,
    BottomRight,
}

/// Anchorからのオフセット（移動量）を定義する構造体
#[derive(Clone, Copy)]
pub struct Shift {
    pub x: f32,
    pub y: f32,
}

/// 水平方向の揃え
#[derive(Clone, Copy)]
pub enum HorizontalAlign {
    Left,
    Center,
    Right,
}

/// 垂直方向の揃え
#[derive(Clone, Copy)]
pub enum VerticalAlign {
    Top,
    Center,
    Bottom,
}

/// テキストの揃え方を定義する構造体
#[derive(Clone, Copy)]
pub struct Align {
    pub horizontal: HorizontalAlign,
    pub vertical: VerticalAlign,
}

/// 画面に描画すべき要素の種類とレイアウト情報を定義するenum
pub enum Renderable<'a> {
    /// 通常のフォントサイズで描画されるテキスト
    Text {
        text: &'a str,
        anchor: Anchor,
        shift: Shift,
        align: Align,
    },
    /// 大きなフォントサイズで描画されるテキスト
    BigText {
        text: &'a str,
        anchor: Anchor,
        shift: Shift,
        align: Align,
    },
}

/// Appの状態を受け取り、描画リスト（UIレイアウト）を構築する
pub fn build_ui<'a>(app: &'a App) -> Vec<Renderable<'a>> {
    vec![
        // 画面中央に表示する大きなテキスト
        Renderable::BigText {
            text: &app.input_text,
            anchor: Anchor::CenterLeft,
            shift: Shift { x: 0.02, y: 0.0 }, // 画面幅の2%右にずらす
            align: Align {
                horizontal: HorizontalAlign::Left,
                vertical: VerticalAlign::Center,
            },
        },
        // 画面左下に表示するステータステキスト
        Renderable::Text {
            text: &app.status_text,
            anchor: Anchor::BottomLeft,
            shift: Shift { x: 0.01, y: -0.02 }, // 画面幅の1%右、画面高さの2%上にずらす
            align: Align {
                horizontal: HorizontalAlign::Left,
                vertical: VerticalAlign::Bottom,
            },
        },
    ]
}

/// AnchorとShiftから、基準となる座標(x, y)を計算する
pub fn calculate_anchor_position(anchor: Anchor, shift: Shift, width: usize, height: usize) -> (i32, i32) {
    let (w, h) = (width as i32, height as i32);
    let base_pos = match anchor {
        Anchor::TopLeft => (0, 0),
        Anchor::TopCenter => (w / 2, 0),
        Anchor::TopRight => (w, 0),
        Anchor::CenterLeft => (0, h / 2),
        Anchor::Center => (w / 2, h / 2),
        Anchor::CenterRight => (w, h / 2),
        Anchor::BottomLeft => (0, h),
        Anchor::BottomCenter => (w / 2, h),
        Anchor::BottomRight => (w, h),
    };
    let shift_x = (width as f32 * shift.x) as i32;
    let shift_y = (height as f32 * shift.y) as i32;
    (base_pos.0 + shift_x, base_pos.1 + shift_y)
}

/// 基準点、テキストの寸法、揃え方から、最終的な描画開始座標（左上）を計算する
pub fn calculate_aligned_position(
    anchor_pos: (i32, i32),
    text_width: u32,
    text_height: u32,
    align: Align,
) -> (i32, i32) {
    let (tw, th) = (text_width as i32, text_height as i32);
    let (ax, ay) = anchor_pos;

    let x = match align.horizontal {
        HorizontalAlign::Left => ax,
        HorizontalAlign::Center => ax - tw / 2,
        HorizontalAlign::Right => ax - tw,
    };

    let y = match align.vertical {
        VerticalAlign::Top => ay,
        VerticalAlign::Center => ay - th / 2,
        VerticalAlign::Bottom => ay - th,
    };

    (x, y)
}
---

./src\wasm.rs
use crate::app::App;
use crate::renderer::{gui_renderer, BG_COLOR};
use crate::ui::{self, Renderable};
use ab_glyph::{Font, FontRef};
use std::cell::RefCell;
use std::rc::Rc;
use wasm_bindgen::prelude::*;
use wasm_bindgen::Clamped;
use web_sys::{CanvasRenderingContext2d, ImageData, KeyboardEvent};

const NORMAL_FONT_SIZE: f32 = 16.0;

/// WASMモジュールのエントリーポイント
#[wasm_bindgen(start)]
pub fn start() -> Result<(), JsValue> {
    console_error_panic_hook::set_once();
    let window = web_sys::window().unwrap();
    let document = window.document().unwrap();
    let body = document.body().unwrap();

    let canvas = document
        .create_element("canvas")?
        .dyn_into::<web_sys::HtmlCanvasElement>()?;
    body.append_child(&canvas)?;
    let context =
        canvas.get_context("2d")?.unwrap().dyn_into::<CanvasRenderingContext2d>()?;

    let font = FontRef::try_from_slice(include_bytes!("../fonts/NotoSerifJP-Regular.ttf"))
        .map_err(|e| JsValue::from_str(&e.to_string()))?;

    let app = Rc::new(RefCell::new(App::new()));

    let size = Rc::new(RefCell::new((0, 0)));

    // 初期サイズ設定とリサイズハンドラ
    {
        let window_clone = window.clone();
        let canvas_clone = canvas.clone();
        let size_clone = size.clone();
        let resize_handler = Closure::<dyn FnMut()>::new(move || {
            let width = window_clone.inner_width().unwrap().as_f64().unwrap() as u32;
            let height = window_clone.inner_height().unwrap().as_f64().unwrap() as u32;
            canvas_clone.set_width(width);
            canvas_clone.set_height(height);
            *size_clone.borrow_mut() = (width as usize, height as usize);
        });
        window.add_event_listener_with_callback("resize", resize_handler.as_ref().unchecked_ref())?;
        resize_handler.forget();
        // 初期サイズを設定するために一度呼び出す
        let window_clone = window.clone();
        let canvas_clone = canvas.clone();
        let size_clone = size.clone();
        let width = window_clone.inner_width().unwrap().as_f64().unwrap() as u32;
        let height = window_clone.inner_height().unwrap().as_f64().unwrap() as u32;
        canvas_clone.set_width(width);
        canvas_clone.set_height(height);
        *size_clone.borrow_mut() = (width as usize, height as usize);
    }

    // キーボードイベントのリスナーを設定
    {
        let app_clone = app.clone();
        let closure = Closure::<dyn FnMut(_)>::new(move |event: KeyboardEvent| {
            let mut app = app_clone.borrow_mut();
            match event.key().as_str() {
                "Backspace" => app.on_backspace(),
                "Enter" => app.on_key('\n'),
                key if key.len() == 1 => app.on_key(key.chars().next().unwrap()),
                _ => {}
            }
        });
        document.add_event_listener_with_callback("keydown", closure.as_ref().unchecked_ref())?;
        closure.forget();
    }

    // requestAnimationFrameによるメインループ
    let f = Rc::new(RefCell::new(None));
    let g = f.clone();
    *g.borrow_mut() = Some(Closure::<dyn FnMut()>::new(move || {
        let (width, height) = *size.borrow();
        let big_font_size = height as f32 * 0.5;
        let app = app.borrow(); // 描画中は不変借用

        // 1. 背景色でピクセルバッファをクリア
        let mut pixel_buffer = vec![BG_COLOR; width * height];

        // 2. UI定義から描画リストを取得
        let render_list = ui::build_ui(&app);

        // 3. 描画リストを解釈して描画
        for item in render_list {
            match item {
                Renderable::BigText { text, anchor, shift, align } => {
                    let (text_width, text_height) = gui_renderer::measure_text(&font, text, big_font_size);
                    let anchor_pos = ui::calculate_anchor_position(anchor, shift, width, height);
                    let (x, y) = ui::calculate_aligned_position(anchor_pos, text_width, text_height, align);
                    gui_renderer::draw_text(
                        &mut pixel_buffer,
                        width,
                        &font,
                        text,
                        (x as f32, y as f32),
                        big_font_size,
                    );
                }
                Renderable::Text { text, anchor, shift, align } => {
                    let (text_width, text_height) = gui_renderer::measure_text(&font, text, NORMAL_FONT_SIZE);
                    let anchor_pos = ui::calculate_anchor_position(anchor, shift, width, height);
                    let (x, y) = ui::calculate_aligned_position(anchor_pos, text_width, text_height, align);
                    gui_renderer::draw_text(
                        &mut pixel_buffer,
                        width,
                        &font,
                        text,
                        (x as f32, y as f32),
                        NORMAL_FONT_SIZE,
                    );
                }
            }
        }

        // 4. 完成したバッファをCanvasに転送
        let mut u8_buffer = Vec::with_capacity(width * height * 4);
        for pixel in pixel_buffer.iter() {
            u8_buffer.extend_from_slice(&[
                ((*pixel >> 16) & 0xFF) as u8,
                ((*pixel >> 8) & 0xFF) as u8,
                (*pixel & 0xFF) as u8,
                255,
            ]);
        }
        let image_data = ImageData::new_with_u8_clamped_array_and_sh(
            Clamped(&u8_buffer),
            width as u32,
            height as u32,
        )
        .unwrap();
        context.put_image_data(&image_data, 0.0, 0.0).unwrap();

        // 次のフレームを要求
        request_animation_frame(f.borrow().as_ref().unwrap());
    }));
    request_animation_frame(g.borrow().as_ref().unwrap());

    Ok(())
}

/// requestAnimationFrameを呼び出すヘルパー関数
fn request_animation_frame(f: &Closure<dyn FnMut()>) {
    web_sys::window()
        .unwrap()
        .request_animation_frame(f.as_ref().unchecked_ref())
        .unwrap();
}

---

